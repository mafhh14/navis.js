# Navis.js v5.6 Features

## Overview

v5.6 introduces advanced query builders: fluent SQL query builder for all SQL databases and a MongoDB query builder with aggregation support. These builders provide a type-safe, database-agnostic way to construct queries without writing raw SQL.

## New Features

### 1. SQL Query Builder

Fluent query builder for SQL databases (PostgreSQL, MySQL, SQLite, SQL Server) with automatic SQL dialect handling.

**Features:**
- Fluent API for SELECT, INSERT, UPDATE, DELETE
- Complex WHERE conditions (nested, OR, AND)
- JOIN support (INNER, LEFT, RIGHT, FULL)
- GROUP BY, HAVING, ORDER BY
- LIMIT, OFFSET (database-specific handling)
- Parameterized queries (SQL injection protection)
- Database-agnostic SQL generation

**Usage:**

```javascript
const { createPool, queryBuilder } = require('navis.js');

const db = createPool({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL,
});

await db.connect();

// SELECT with WHERE
const users = await queryBuilder(db, 'users')
  .select(['id', 'name', 'email'])
  .where('status', '=', 'active')
  .where('age', '>', 18)
  .orderBy('name', 'ASC')
  .limit(10)
  .execute();

// Complex WHERE with nested conditions
const products = await queryBuilder(db, 'products')
  .select('*')
  .where((qb) => {
    qb.where('category', '=', 'Electronics')
      .orWhere('price', '<', 50);
  })
  .where('in_stock', '>', 0)
  .whereIn('category', ['Electronics', 'Books'])
  .orderBy('price', 'DESC')
  .execute();

// JOIN
const orders = await queryBuilder(db)
  .select(['users.name', 'orders.total', 'orders.created_at'])
  .from('users')
  .leftJoin('orders', 'users.id', '=', 'orders.user_id')
  .where('users.status', '=', 'active')
  .execute();

// INSERT
const result = await queryBuilder(db)
  .insert('users', {
    name: 'John Doe',
    email: 'john@example.com',
    age: 30,
    status: 'active',
  })
  .execute();

// UPDATE
await queryBuilder(db)
  .update('users', {
    status: 'inactive',
    updated_at: new Date(),
  })
  .where('id', '=', userId)
  .execute();

// DELETE
await queryBuilder(db)
  .delete('users')
  .where('status', '=', 'inactive')
  .where('last_login', '<', new Date('2024-01-01'))
  .execute();
```

**Advanced Features:**

```javascript
// WHERE conditions
queryBuilder(db, 'users')
  .where('name', '=', 'John')           // Simple equality
  .where('age', '>', 18)                 // Greater than
  .where('email', 'LIKE', '%@gmail.com') // LIKE
  .whereIn('role', ['admin', 'user'])    // IN clause
  .whereNotIn('id', [1, 2, 3])          // NOT IN
  .whereNull('deleted_at')               // IS NULL
  .whereNotNull('email')                 // IS NOT NULL
  .orWhere('status', '=', 'pending')     // OR condition
  .execute();

// Nested WHERE conditions
queryBuilder(db, 'products')
  .where((qb) => {
    qb.where('category', '=', 'Electronics')
      .orWhere('category', '=', 'Books');
  })
  .where((qb) => {
    qb.where('price', '>', 100)
      .orWhere('discount', '>', 0.5);
  })
  .execute();

// GROUP BY and HAVING
queryBuilder(db, 'orders')
  .select(['user_id', 'SUM(total) as total_spent', 'COUNT(*) as order_count'])
  .groupBy('user_id')
  .having('SUM(total)', '>', 1000)
  .orderBy('total_spent', 'DESC')
  .execute();

// Multiple JOINs
queryBuilder(db)
  .select(['users.name', 'orders.total', 'products.name as product_name'])
  .from('users')
  .leftJoin('orders', 'users.id', '=', 'orders.user_id')
  .leftJoin('order_items', 'orders.id', '=', 'order_items.order_id')
  .leftJoin('products', 'order_items.product_id', '=', 'products.id')
  .where('users.status', '=', 'active')
  .execute();

// Pagination
const page = 1;
const perPage = 20;
const offset = (page - 1) * perPage;

const results = await queryBuilder(db, 'users')
  .select('*')
  .orderBy('created_at', 'DESC')
  .limit(perPage)
  .offset(offset)
  .execute();
```

**Database-Specific Handling:**

The query builder automatically handles SQL dialect differences:

- **PostgreSQL**: Uses `$1, $2, ...` for parameters, supports `LIMIT` and `OFFSET`
- **MySQL**: Uses `?` for parameters, supports `LIMIT` and `OFFSET`
- **SQLite**: Uses `?` for parameters, supports `LIMIT` and `OFFSET`
- **SQL Server**: Uses `@p0, @p1, ...` for parameters, uses `TOP` or `OFFSET/FETCH` for pagination

**Getting SQL String (for debugging):**

```javascript
const query = queryBuilder(db, 'users')
  .select(['id', 'name'])
  .where('status', '=', 'active')
  .orderBy('name', 'ASC');

const { sql, params } = query.toSQL();
console.log('SQL:', sql);
console.log('Params:', params);

// Execute
const users = await query.execute();
```

### 2. MongoDB Query Builder

Fluent query builder for MongoDB with aggregation pipeline support.

**Features:**
- Fluent API for FIND, INSERT, UPDATE, DELETE
- Filter conditions (equals, gt, gte, lt, lte, in, notIn, contains)
- Projection (select/exclude fields)
- Sorting and pagination
- Aggregation pipeline
- Type-safe operations

**Usage:**

```javascript
const { createPool, mongoQueryBuilder } = require('navis.js');

const db = createPool({
  type: 'mongodb',
  connectionString: process.env.MONGODB_URI,
});

await db.connect();

// FIND with filters
const users = await mongoQueryBuilder(db, 'users')
  .where('status', 'active')
  .gt('age', 18)
  .in('role', ['user', 'admin'])
  .select(['name', 'email', 'age'])
  .sortDesc('created_at')
  .limit(10)
  .find();

// FIND ONE
const user = await mongoQueryBuilder(db, 'users')
  .where('email', 'john@example.com')
  .findOne();

// COUNT
const count = await mongoQueryBuilder(db, 'users')
  .where('status', 'active')
  .gt('age', 18)
  .count();

// INSERT
const result = await mongoQueryBuilder(db, 'users')
  .insert({
    name: 'John Doe',
    email: 'john@example.com',
    age: 30,
    status: 'active',
    created_at: new Date(),
  })
  .execute();

// INSERT MANY
const result = await mongoQueryBuilder(db, 'users')
  .insert([
    { name: 'Alice', email: 'alice@example.com' },
    { name: 'Bob', email: 'bob@example.com' },
  ])
  .execute();

// UPDATE
const result = await mongoQueryBuilder(db, 'users')
  .update(
    { status: 'inactive', updated_at: new Date() },
    { upsert: false, multi: true }
  )
  .where('last_login', { $lt: new Date('2024-01-01') })
  .execute();

// DELETE
const result = await mongoQueryBuilder(db, 'users')
  .delete({ multi: true })
  .where('status', 'inactive')
  .where('deleted_at', { $exists: true })
  .execute();
```

**Advanced Filtering:**

```javascript
// Comparison operators
mongoQueryBuilder(db, 'products')
  .equals('category', 'Electronics')      // =
  .notEquals('status', 'discontinued')    // !=
  .gt('price', 100)                       // >
  .gte('stock', 10)                       // >=
  .lt('price', 1000)                      // <
  .lte('discount', 0.5)                   // <=
  .in('category', ['Electronics', 'Books']) // IN
  .notIn('id', [1, 2, 3])                // NOT IN
  .contains('name', 'laptop', false)      // Regex (case-insensitive)
  .exists('description', true)            // Field exists
  .whereNull('deleted_at')                // IS NULL
  .whereNotNull('email')                  // IS NOT NULL
  .find();

// Complex filters with AND/OR
mongoQueryBuilder(db, 'products')
  .where('status', 'active')
  .and({ category: 'Electronics', price: { $gt: 100 } })
  .or([
    { category: 'Books' },
    { discount: { $gt: 0.5 } },
  ])
  .find();

// Object syntax
mongoQueryBuilder(db, 'users')
  .where({
    status: 'active',
    age: { $gt: 18, $lt: 65 },
    role: { $in: ['user', 'admin'] },
  })
  .find();
```

**Projection and Sorting:**

```javascript
// Select specific fields
mongoQueryBuilder(db, 'users')
  .select(['name', 'email', 'age'])
  .find();

// Exclude fields
mongoQueryBuilder(db, 'users')
  .exclude(['password', 'token'])
  .find();

// Custom projection
mongoQueryBuilder(db, 'users')
  .select({
    name: 1,
    email: 1,
    fullName: { $concat: ['$firstName', ' ', '$lastName'] },
  })
  .find();

// Sorting
mongoQueryBuilder(db, 'users')
  .sort('name', 1)              // ASC
  .sortDesc('created_at')       // DESC
  .sort({ name: 1, age: -1 })   // Multiple fields
  .find();

// Pagination
mongoQueryBuilder(db, 'users')
  .skip(20)                     // Skip first 20
  .limit(10)                     // Limit to 10
  .find();
```

**Aggregation Pipeline:**

```javascript
// Aggregation pipeline
const results = await mongoQueryBuilder(db, 'orders')
  .aggregate()
  .match({ status: 'completed' })
  .group({
    _id: '$user_id',
    totalSpent: { $sum: '$total' },
    orderCount: { $sum: 1 },
    avgOrder: { $avg: '$total' },
  })
  .project({
    userId: '$_id',
    totalSpent: 1,
    orderCount: 1,
    avgOrder: 1,
  })
  .sortStage({ totalSpent: -1 })
  .limitStage(10)
  .aggregateExecute();

// Complex aggregation
const stats = await mongoQueryBuilder(db, 'products')
  .aggregate()
  .match({ in_stock: { $gt: 0 } })
  .group({
    _id: '$category',
    totalProducts: { $sum: 1 },
    avgPrice: { $avg: '$price' },
    maxPrice: { $max: '$price' },
    minPrice: { $min: '$price' },
    totalValue: { $sum: { $multiply: ['$price', '$in_stock'] } },
  })
  .project({
    category: '$_id',
    totalProducts: 1,
    avgPrice: { $round: ['$avgPrice', 2] },
    priceRange: {
      min: '$minPrice',
      max: '$maxPrice',
    },
    totalValue: 1,
  })
  .sortStage({ totalValue: -1 })
  .aggregateExecute();
```

### 3. TypeScript Support

Full TypeScript support with type definitions for both query builders.

**Usage:**

```typescript
import {
  createPool,
  queryBuilder,
  mongoQueryBuilder,
  DatabasePool,
  QueryBuilder,
  MongoDBQueryBuilder,
} from 'navis.js';

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  status: string;
}

// SQL Query Builder with TypeScript
const db: DatabasePool = createPool({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL!,
});

await db.connect();

const users = await queryBuilder(db, 'users')
  .select(['id', 'name', 'email'])
  .where('status', '=', 'active')
  .where((qb: QueryBuilder) => {
    qb.where('age', '>', 18)
      .orWhere('role', '=', 'admin');
  })
  .orderBy('name', 'ASC')
  .limit(10)
  .execute() as User[];

// MongoDB Query Builder with TypeScript
const mongoDb: DatabasePool = createPool({
  type: 'mongodb',
  connectionString: process.env.MONGODB_URI!,
});

await mongoDb.connect();

const mongoUsers = await mongoQueryBuilder(mongoDb, 'users')
  .where('status', 'active')
  .gt('age', 18)
  .find() as User[];

await db.close();
await mongoDb.close();
```

## Complete Example

```javascript
const {
  NavisApp,
  createPool,
  queryBuilder,
  mongoQueryBuilder,
  response,
} = require('navis.js');

const app = new NavisApp();

// SQL Query Builder Example
app.get('/sql/users', async (req, res) => {
  try {
    const db = createPool({
      type: 'postgres',
      connectionString: process.env.DATABASE_URL,
    });

    await db.connect();

    const users = await queryBuilder(db, 'users')
      .select(['id', 'name', 'email', 'age'])
      .where('status', '=', 'active')
      .where('age', '>=', 18)
      .whereIn('role', ['user', 'admin'])
      .orderBy('name', 'ASC')
      .limit(20)
      .offset(0)
      .execute();

    await db.close();

    response.success(res, { users });
  } catch (error) {
    response.error(res, error.message, 500);
  }
});

// Complex SQL Query
app.get('/sql/products', async (req, res) => {
  try {
    const db = createPool({
      type: 'postgres',
      connectionString: process.env.DATABASE_URL,
    });

    await db.connect();

    const products = await queryBuilder(db)
      .select([
        'products.id',
        'products.name',
        'products.price',
        'categories.name as category_name',
        'COUNT(order_items.id) as order_count',
      ])
      .from('products')
      .leftJoin('categories', 'products.category_id', '=', 'categories.id')
      .leftJoin('order_items', 'products.id', '=', 'order_items.product_id')
      .where('products.status', '=', 'active')
      .where((qb) => {
        qb.where('products.price', '>', 10)
          .orWhere('products.discount', '>', 0.1);
      })
      .groupBy('products.id', 'categories.name')
      .having('COUNT(order_items.id)', '>', 5)
      .orderBy('order_count', 'DESC')
      .limit(10)
      .execute();

    await db.close();

    response.success(res, { products });
  } catch (error) {
    response.error(res, error.message, 500);
  }
});

// MongoDB Query Builder Example
app.get('/mongo/users', async (req, res) => {
  try {
    const db = createPool({
      type: 'mongodb',
      connectionString: process.env.MONGODB_URI,
    });

    await db.connect();

    const users = await mongoQueryBuilder(db, 'users')
      .where('status', 'active')
      .gt('age', 18)
      .in('role', ['user', 'admin'])
      .select(['name', 'email', 'age'])
      .sortDesc('created_at')
      .limit(20)
      .find();

    await db.close();

    response.success(res, { users });
  } catch (error) {
    response.error(res, error.message, 500);
  }
});

// MongoDB Aggregation
app.get('/mongo/stats', async (req, res) => {
  try {
    const db = createPool({
      type: 'mongodb',
      connectionString: process.env.MONGODB_URI,
    });

    await db.connect();

    const stats = await mongoQueryBuilder(db, 'orders')
      .aggregate()
      .match({ status: 'completed' })
      .group({
        _id: '$user_id',
        totalSpent: { $sum: '$total' },
        orderCount: { $sum: 1 },
      })
      .sortStage({ totalSpent: -1 })
      .limitStage(10)
      .aggregateExecute();

    await db.close();

    response.success(res, { stats });
  } catch (error) {
    response.error(res, error.message, 500);
  }
});

app.listen(3000);
```

## Best Practices

1. **Always use parameterized queries** - The query builders automatically handle parameterization to prevent SQL injection.

2. **Close database connections** - Always call `db.close()` after operations to free up resources.

3. **Use transactions for multiple operations** - For complex operations, consider using database transactions.

4. **Handle errors gracefully** - Wrap query operations in try-catch blocks.

5. **Use TypeScript for type safety** - Leverage TypeScript definitions for better IDE support and type checking.

6. **Optimize queries** - Use appropriate indexes, limit result sets, and use projections in MongoDB.

7. **Database-specific considerations**:
   - PostgreSQL: Use connection pooling for better performance
   - MySQL: Consider using `mysql2` for better async support
   - SQLite: Use `better-sqlite3` for synchronous operations or `sqlite3` for async
   - SQL Server: Ensure proper connection string format
   - MongoDB: Use appropriate indexes for frequently queried fields

## Examples

See `examples/query-builder-demo.js` and `examples/query-builder-demo.ts` for complete working examples.

## Migration from Raw SQL

If you're migrating from raw SQL queries, the query builders provide a drop-in replacement:

**Before:**
```javascript
const users = await db.query(
  'SELECT id, name, email FROM users WHERE status = $1 AND age > $2 ORDER BY name ASC LIMIT 10',
  ['active', 18]
);
```

**After:**
```javascript
const users = await queryBuilder(db, 'users')
  .select(['id', 'name', 'email'])
  .where('status', '=', 'active')
  .where('age', '>', 18)
  .orderBy('name', 'ASC')
  .limit(10)
  .execute();
```

The query builder approach is more readable, type-safe, and database-agnostic.

