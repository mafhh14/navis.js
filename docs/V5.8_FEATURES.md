# Navis.js v5.8 Features: Advanced Caching Strategies

## Overview

v5.8 introduces advanced caching strategies that go beyond basic TTL-based caching. These features enable production-grade caching with multi-level support, intelligent invalidation, cache warming, and comprehensive statistics.

## Features

### 1. Multi-Level Caching

**L1 Cache (In-Memory)**: Fast, local cache for frequently accessed data  
**L2 Cache (Redis/Remote)**: Distributed cache for shared data across instances

- Automatic promotion from L2 to L1 on read
- Write strategies: write-through, write-back, write-around
- Configurable TTL for each level

### 2. Cache Warming

Pre-populate cache with frequently accessed data to reduce cold starts and improve response times.

### 3. Cache Invalidation

- **Tag-based invalidation**: Invalidate all items with specific tags
- **Pattern-based invalidation**: Invalidate keys matching regex patterns
- **Cascading invalidation**: Automatically handle related cache entries

### 4. Cache Statistics

Comprehensive statistics including:
- Hit/miss rates
- L1 vs L2 hit distribution
- Cache size
- Error counts
- Write-back queue size

### 5. Cache Compression

Automatic compression for large values (>1KB) to reduce memory usage and improve performance.

### 6. Cache Stampede Prevention

Prevents multiple simultaneous requests for the same key from overwhelming the cache or backend.

### 7. Cache Versioning

Support for cache versioning to handle schema changes and cache migrations.

## Usage

### Basic Setup

```javascript
const { AdvancedCache, Cache, RedisCache } = require('navis.js');

// Create L1 cache (in-memory)
const l1Cache = new Cache({
  maxSize: 1000,
  defaultTTL: 300000, // 5 minutes
});

// Create L2 cache (Redis - optional)
const l2Cache = new RedisCache({
  defaultTTL: 3600, // 1 hour
  prefix: 'navis:',
});
await l2Cache.connect();

// Create advanced cache
const cache = new AdvancedCache({
  l1Cache,
  l2Cache,
  writeStrategy: 'write-through', // or 'write-back', 'write-around'
});
```

### Setting Values

```javascript
// Basic set
await cache.set('user:1', { id: 1, name: 'John' });

// With options
await cache.set('user:1', userData, {
  ttl: 600000, // 10 minutes
  tags: ['user', 'user:1'],
  compress: true, // Enable compression for large values
});
```

### Getting Values

```javascript
// Get value (checks L1, then L2)
const user = await cache.get('user:1');
```

### Cache Warming

```javascript
const warmData = [
  { key: 'product:1', value: product1, options: { tags: ['product'] } },
  { key: 'product:2', value: product2, options: { tags: ['product'] } },
  { key: 'product:3', value: product3, options: { tags: ['product'] } },
];

await cache.warm(warmData);
```

### Cache Invalidation

```javascript
// Invalidate by tag
await cache.invalidateByTag('user');
await cache.invalidateByTag(['user', 'product']);

// Invalidate by pattern
await cache.invalidateByPattern(/^product:/);
await cache.invalidateByPattern('user:.*');
```

### Cache Statistics

```javascript
const stats = cache.getStats();
console.log('Hit Rate:', stats.hitRate);
console.log('L1 Hits:', stats.l1Hits);
console.log('L2 Hits:', stats.l2Hits);
console.log('Total Operations:', stats.total);

// Reset statistics
cache.resetStats();
```

### Write Strategies

#### Write-Through (Default)
Writes to both L1 and L2 immediately. Best for consistency.

```javascript
const cache = new AdvancedCache({
  l1Cache,
  l2Cache,
  writeStrategy: 'write-through',
});
```

#### Write-Back
Writes to L1 immediately, queues for L2. Best for performance.

```javascript
const cache = new AdvancedCache({
  l1Cache,
  l2Cache,
  writeStrategy: 'write-back',
});

// Flush queue when needed
await cache.flush();
```

#### Write-Around
Writes to L2 only, L1 populated on read. Best for write-heavy workloads.

```javascript
const cache = new AdvancedCache({
  l1Cache,
  l2Cache,
  writeStrategy: 'write-around',
});
```

### Cache Compression

```javascript
// Automatic compression for values > 1KB
await cache.set('large:data', largeData, {
  compress: true,
});

// Compression threshold is configurable
const cache = new AdvancedCache({
  l1Cache,
  compressThreshold: 2048, // Compress values > 2KB
});
```

### Cache Versioning

```javascript
// Version 1.0 cache
const v1Cache = new AdvancedCache({
  l1Cache,
  version: '1.0',
});

// Version 2.0 cache (separate namespace)
const v2Cache = new AdvancedCache({
  l1Cache,
  version: '2.0',
});

// Same key, different versions
await v1Cache.set('key', { version: '1.0' });
await v2Cache.set('key', { version: '2.0' });
```

## Integration with NavisApp

```javascript
const { NavisApp, AdvancedCache, Cache, cache } = require('navis.js');

const app = new NavisApp();

// Create advanced cache
const advancedCache = new AdvancedCache({
  l1Cache: new Cache(),
});

// Use with cache middleware
app.get('/users/:id', cache({
  cacheStore: advancedCache,
  ttl: 1800,
  keyGenerator: (req) => `user:${req.params.id}`,
}), async (req, res) => {
  const user = await getUserFromDB(req.params.id);
  res.body = user;
});

// Invalidate cache on update
app.put('/users/:id', async (req, res) => {
  await updateUser(req.params.id, req.body);
  
  // Invalidate cache
  await advancedCache.delete(`user:${req.params.id}`);
  await advancedCache.invalidateByTag('users');
  
  res.body = { success: true };
});
```

## Best Practices

1. **Use tags for logical grouping**: Tag related cache entries for easy invalidation
2. **Choose appropriate write strategy**: 
   - Write-through for consistency
   - Write-back for performance
   - Write-around for write-heavy workloads
3. **Warm cache on startup**: Pre-populate frequently accessed data
4. **Monitor statistics**: Track hit rates and adjust TTLs accordingly
5. **Use compression for large values**: Reduces memory usage
6. **Version your cache**: Handle schema changes gracefully
7. **Invalidate on updates**: Keep cache consistent with data source

## Performance Considerations

- **L1 Cache**: Extremely fast (<1ms), limited by memory
- **L2 Cache**: Fast (1-10ms), shared across instances
- **Compression**: Adds ~1-5ms overhead, saves memory
- **Write-back**: Reduces L2 write latency, requires periodic flushing

## Migration from Basic Cache

```javascript
// Before (v5)
const cache = new Cache();
cache.set('key', 'value');
const value = cache.get('key');

// After (v5.8)
const advancedCache = new AdvancedCache({
  l1Cache: new Cache(),
});
await advancedCache.set('key', 'value');
const value = await advancedCache.get('key');
```

Note: AdvancedCache methods are async, while basic Cache methods are sync.

## TypeScript Support

Full TypeScript definitions are available:

```typescript
import {
  AdvancedCache,
  AdvancedCacheOptions,
  AdvancedCacheSetOptions,
  AdvancedCacheStats,
} from 'navis.js';

const options: AdvancedCacheOptions = {
  l1Cache: new Cache(),
  writeStrategy: 'write-through',
};

const cache = new AdvancedCache(options);

const setOptions: AdvancedCacheSetOptions = {
  ttl: 600000,
  tags: ['user'],
};

await cache.set('user:1', userData, setOptions);

const stats: AdvancedCacheStats = cache.getStats();
```

## Examples

See `examples/advanced-cache-demo.js` and `examples/advanced-cache-demo.ts` for comprehensive examples.

