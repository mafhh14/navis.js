# Navis.js v5.7 Features

## Overview

v5.7 introduces ORM-like features and database migrations, providing a higher-level abstraction for database operations with model definitions, relationships, hooks, and a migration system.

## New Features

### 1. ORM-like Model System

A lightweight ORM system that provides model definitions, relationships, hooks, and validation.

**Features:**
- Model definitions with table/collection mapping
- CRUD operations (create, read, update, delete)
- Model relationships (hasMany, belongsTo, hasOne)
- Lifecycle hooks (beforeSave, afterSave, beforeCreate, etc.)
- Model validation
- Change tracking (isDirty, getChanged)
- TypeScript support

**Usage:**

```javascript
const { Model, createPool } = require('navis.js');

// Define a Model
class User extends Model {
  static get tableName() {
    return 'users';
  }

  static get primaryKey() {
    return 'id';
  }

  // Validation
  async validate() {
    if (!this.email || !this.email.includes('@')) {
      throw new Error('Invalid email address');
    }
    return true;
  }

  // Hooks
  async beforeSave() {
    if (this._isNew) {
      this.created_at = new Date();
    }
    this.updated_at = new Date();
  }
}

// Set database
const db = createPool({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL,
});

await db.connect();
User.setDatabase(db);

// Create
const user = await User.create({
  name: 'John Doe',
  email: 'john@example.com',
  age: 30,
});

// Find
const users = await User.find({ status: 'active' });
const user = await User.findById(1);
const user = await User.findOne({ email: 'john@example.com' });

// Update
user.name = 'Jane Doe';
await user.save();

// Delete
await user.delete();

// Count
const count = await User.count({ status: 'active' });
```

**Model Relationships:**

```javascript
class User extends Model {
  static get tableName() { return 'users'; }
}

class Post extends Model {
  static get tableName() { return 'posts'; }
}

class Comment extends Model {
  static get tableName() { return 'comments'; }
}

// Define relationships
Post.belongsTo('author', User, 'user_id');
User.hasMany('posts', Post, 'user_id');
Post.hasMany('comments', Comment, 'post_id');
Comment.belongsTo('post', Post, 'post_id');
Comment.belongsTo('author', User, 'user_id');

// Use relationships
const user = await User.findById(1);
const posts = await user.posts; // Get all posts by this user

const post = await Post.findById(1);
const author = await post.author; // Get post author
const comments = await post.comments; // Get post comments
```

**Model Hooks:**

```javascript
class User extends Model {
  async beforeSave() {
    // Called before save (both create and update)
    this.updated_at = new Date();
  }

  async afterSave() {
    // Called after save
    console.log('User saved:', this.id);
  }

  async beforeCreate() {
    // Called only before create
    this.created_at = new Date();
  }

  async afterCreate() {
    // Called only after create
    console.log('New user created:', this.id);
  }

  async beforeUpdate() {
    // Called only before update
    this.version = (this.version || 0) + 1;
  }

  async afterUpdate() {
    // Called only after update
    console.log('User updated:', this.id);
  }

  async beforeDelete() {
    // Called before delete
    console.log('Deleting user:', this.id);
  }

  async afterDelete() {
    // Called after delete
    console.log('User deleted');
  }

  async validate() {
    // Custom validation
    if (!this.email) {
      throw new Error('Email is required');
    }
    return true;
  }
}
```

**Model Options:**

```javascript
// Find with options
const users = await User.find(
  { status: 'active' },
  {
    select: ['id', 'name', 'email'],
    orderBy: 'name',
    orderDirection: 'ASC',
    limit: 10,
    offset: 0,
  }
);

// For MongoDB
const users = await User.find(
  { status: 'active' },
  {
    select: ['name', 'email'],
    sort: { created_at: -1 },
    limit: 10,
    skip: 0,
  }
);
```

**Change Tracking:**

```javascript
const user = await User.findById(1);

// Check if modified
if (user.isDirty()) {
  console.log('User has unsaved changes');
}

// Get changed fields
const changes = user.getChanged();
console.log('Changed fields:', changes);

// Save only if changed
if (user.isDirty()) {
  await user.save();
}

// Reload from database
await user.reload();
```

### 2. Database Migrations

A migration system for managing database schema changes with up/down support and tracking.

**Features:**
- Migration files with up/down functions
- Automatic migration tracking
- Batch management
- Rollback support
- Migration status
- Database-agnostic (SQL and MongoDB)

**Usage:**

```javascript
const { createPool, createMigration } = require('navis.js');

const db = createPool({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL,
});

await db.connect();

// Create migration instance
const migration = createMigration(db, './migrations');

// Initialize migrations table
await migration.init();

// Run pending migrations
const result = await migration.up();
console.log(result.message); // "Ran 3 migration(s)"
console.log(result.executed); // ["001_create_users", "002_create_posts", ...]

// Rollback last batch
const rollback = await migration.down(1);
console.log(rollback.message); // "Rolled back 1 migration(s)"

// Check migration status
const status = await migration.status();
console.log(status.executed); // Number of executed migrations
console.log(status.pending); // Number of pending migrations
console.log(status.files); // Array of all migration files with status
```

**Migration File Structure:**

Create migration files in your `migrations/` directory:

```javascript
// migrations/001_create_users_table.js
module.exports = {
  async up(dbPool) {
    const dbType = dbPool.type.toLowerCase();

    if (dbType === 'mongodb') {
      // MongoDB: Create collection and indexes
      const collection = dbPool.db.collection('users');
      await collection.createIndex({ email: 1 }, { unique: true });
    } else {
      // SQL: Create table
      const sql = `
        CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          email TEXT NOT NULL UNIQUE,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `.replace(/AUTOINCREMENT/g, dbType === 'postgres' || dbType === 'postgresql' 
        ? 'SERIAL' 
        : dbType === 'mysql' || dbType === 'mariadb' 
        ? 'AUTO_INCREMENT' 
        : 'AUTOINCREMENT'
      );

      await dbPool.query(sql);
    }
  },

  async down(dbPool) {
    const dbType = dbPool.type.toLowerCase();

    if (dbType === 'mongodb') {
      const collection = dbPool.db.collection('users');
      await collection.drop();
    } else {
      await dbPool.query('DROP TABLE IF EXISTS users');
    }
  },
};
```

**Migration Naming:**

Migration files should be named with a numeric prefix:
- `001_create_users_table.js`
- `002_create_posts_table.js`
- `003_add_indexes.js`

The migrations will run in numerical order.

**Database-Specific SQL:**

The migration system automatically handles SQL dialect differences:

```javascript
// PostgreSQL
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

// MySQL
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

// SQLite
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

// SQL Server
CREATE TABLE users (
  id INT IDENTITY(1,1) PRIMARY KEY,
  name NVARCHAR(255) NOT NULL,
  created_at DATETIME2 DEFAULT GETDATE()
);
```

## Complete Example

```javascript
const {
  NavisApp,
  createPool,
  Model,
  createMigration,
  response,
} = require('navis.js');
const path = require('path');

const app = new NavisApp();

// Define Models
class User extends Model {
  static get tableName() {
    return 'users';
  }

  static get primaryKey() {
    return 'id';
  }

  async validate() {
    if (!this.email || !this.email.includes('@')) {
      throw new Error('Invalid email');
    }
    return true;
  }

  async beforeSave() {
    if (this._isNew) {
      this.created_at = new Date();
    }
    this.updated_at = new Date();
  }
}

class Post extends Model {
  static get tableName() {
    return 'posts';
  }

  static get primaryKey() {
    return 'id';
  }
}

// Define relationships
Post.belongsTo('author', User, 'user_id');
User.hasMany('posts', Post, 'user_id');

// Initialize database
let db = null;

app.get('/init', async (req, res) => {
  db = createPool({
    type: 'sqlite',
    connectionString: ':memory:',
  });

  await db.connect();
  User.setDatabase(db);
  Post.setDatabase(db);

  // Run migrations
  const migration = createMigration(db, path.join(__dirname, 'migrations'));
  await migration.init();
  await migration.up();

  response.success(res, { message: 'Database initialized' });
});

// Create user
app.post('/users', async (req, res) => {
  try {
    const user = await User.create({
      name: req.body.name,
      email: req.body.email,
    });

    response.success(res, { user: user.toJSON() }, 201);
  } catch (error) {
    response.error(res, error.message, 400);
  }
});

// Get users
app.get('/users', async (req, res) => {
  const users = await User.find({}, {
    orderBy: 'name',
    orderDirection: 'ASC',
  });

  response.success(res, {
    users: users.map(u => u.toJSON()),
  });
});

// Get user with posts
app.get('/users/:id/posts', async (req, res) => {
  const user = await User.findById(req.params.id);
  if (!user) {
    return response.error(res, 'User not found', 404);
  }

  const posts = await user.posts;

  response.success(res, {
    user: user.toJSON(),
    posts: posts.map(p => p.toJSON()),
  });
});

app.listen(3000);
```

## TypeScript Support

```typescript
import { Model, createPool, DatabasePool } from 'navis.js';

interface UserData {
  id?: number;
  name: string;
  email: string;
  age?: number;
}

class User extends Model {
  static get tableName(): string {
    return 'users';
  }

  static get primaryKey(): string {
    return 'id';
  }

  async validate(): Promise<boolean> {
    const email = (this as any).email;
    if (!email || !email.includes('@')) {
      throw new Error('Invalid email');
    }
    return true;
  }
}

const db: DatabasePool = createPool({
  type: 'postgres',
  connectionString: process.env.DATABASE_URL!,
});

await db.connect();
User.setDatabase(db);

const user = await User.create({
  name: 'John Doe',
  email: 'john@example.com',
} as UserData);
```

## Best Practices

1. **Always set database before using models** - Call `Model.setDatabase(dbPool)` after connecting.

2. **Use migrations for schema changes** - Never modify database schema directly in production.

3. **Test migrations** - Always test both `up` and `down` migrations.

4. **Use model hooks for common logic** - Use `beforeSave` for timestamps, `validate` for validation.

5. **Leverage relationships** - Use relationships instead of manual joins when possible.

6. **Handle errors** - Wrap model operations in try-catch blocks.

7. **Use transactions for complex operations** - For multiple related operations, consider using database transactions.

8. **Migration naming** - Use descriptive names with numeric prefixes: `001_create_users`, `002_add_email_index`.

## Examples

See `examples/orm-migrations-demo.js` and `examples/orm-migrations-demo.ts` for complete working examples.

## Migration Files

Example migration files are available in `examples/migrations/`:
- `001_create_users_table.js`
- `002_create_posts_table.js`
- `003_create_comments_table.js`

